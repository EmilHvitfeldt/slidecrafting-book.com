{"title":"Fragments","markdown":{"yaml":{"title":"Fragments"},"headingText":"Highlight incremental slides","containsRefs":false,"markdown":"\n\n\nThe use of [incremental lists](https://quarto.org/docs/presentations/revealjs/#incremental-lists) is a great way to add a little something to a set of slides. It also avoids a wall of text, allowing the presenter to show one bullet at a time. All in all, this is helpful as it can be used to focus the viewers' attention. \n\nAs a reminder, we create an incremental list using the following syntax:\n\n```markdown\n::: {.incremental}\n- thing 1\n- thing 2\n:::\n```\n\nWe can add another class to this div and use it to style it more. \n\n```markdown\n::: {.incremental .highlight-last}\n- thing 1\n- thing 2\n:::\n```\n\nthen we use this to style our list. Below `.current-fragment` refers to the last shown item in the list. Setting the `color: grey` isn't necessary, but it is a way to downplay the \"not-current\" items\n\n```scss\n.highlight-last  {\n  color: grey;\n  .current-fragment {\n    color: #5500ff;\n  }\n}\n```\n\nThese together yield these slides:\n\n<iframe class=\"slide-deck\" src=\"../examples/fragments/tip-1.html\">\n\n</iframe>\n\n<a href=\"../examples/fragments/tip-1.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"../examples/fragments/tip-1.scss\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands sass >}}scss<a>\n\n## Changing fragments with CSS\n\nAt the most fundamental level, a fragment can be split into 3 stages\n\n- before\n- current\n- after\n\ndetermining which stage is handled completely by revealjs using the `fragment-index` attribute. The way we can make things happen is to apply a different style to each of the 3 stages.\n\nthe maximal fragment signature is as follows, with `fragment-name` being the name of the fragment in question. For them to work properly you have to list them in the following order. Which corresponds to `before`, `after`, and `current`.\n\n```css\n.reveal .slides section .fragment.fragment-name {\n}\n\n.reveal .slides section .fragment.fragment-name.visible {\n}\n\n.reveal .slides section .fragment.fragment-name.current-fragment {\n}\n```\n\n:::: {.callout-important}\nThe reason why this ordering is important is because `.visible` and `.current-fragment` are triggered at the same time. And because I simplified the order a little too much. There isn't `before`, `current`, and `after`. Instead, we have `always`, `current`, and `not-before-current`. In essence, they do the same, as long as you order them in this order to make sure they cascade properly.\n:::\n\nBefore we try to implement a fragment by ourselves, we need to note one thing real quick. Each of these stages is styled a [specific way by default](https://github.com/quarto-dev/quarto-cli/blob/39dc173c4869ebaf4d6bb087a972acb87533b64e/src/resources/formats/revealjs/reveal/css/reveal.scss#L51-L65). In practice, what this means is that the `before` style has the following attributes set to make the text invisible:\n\n```css\nopacity: 0;\nvisibility: hidden;\n```\n\nIf you want the text to be visible before the fragment triggers, simply set these two attributes to `unset`.\n\nAnother note I would like to add is that while you are able to modify anything in a fragment, as it is just triggering CSS, you should be careful about position and size. While you might be able to make it work, it is likely to cause a lot of shifting and jittering as elements resize.\n\n:::: {.callout-tip}\nLooking at the [source code](https://github.com/quarto-dev/quarto-cli/blob/39dc173c4869ebaf4d6bb087a972acb87533b64e/src/resources/formats/revealjs/reveal/css/reveal.scss#L67-L207) for the default fragments gives us a good idea for how different styles of fragments work.\n:::\n\n## Example 1\n\nThis first example illustrates how the different phases work in a fragment. We have thus created an `rgb` fragment that assigns a different color to each of the 3 phases. We `unset` both `opacity` and `visibility` to have the text appear beforehand. This leaves us with the following fragment:\n\n```scss\n.reveal .slides section .fragment.rgb {\n  opacity: unset;\n  visibility: unset;\n  color: red;\n}\n\n.reveal .slides section .fragment.rgb.visible {\n  color: blue;\n}\n\n.reveal .slides section .fragment.rgb.current-fragment {\n  color: green;\n}\n```\n\nAdvancing and de-advancing(?) the slides showcase how the different classes are applied for fragments.\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-rgb.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-rgb.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/rgb.scss\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands sass >}}scss<a>\n\nWorth noting that this single fragment could be rewritten as the following using SCSS nesting.\n\n```scss\n.reveal .slides section .fragment.rgb {\n  opacity: unset;\n  visibility: unset;\n  color: red;\n\n  &.visible {\n    color: blue;\n  }\n\n  &.current-fragment {\n    color: green;\n  }\n}\n```\n\n## Example 2\n\nOne custom fragment I use from time to time is the background highlighted style. And it is very simple, instead of changing the color of the text, it changes the background color. I find that it is a much stronger indication than changing the text itself.\n\nThis fragment gives us two things. I leave the text visible beforehand. Then it turns the background orange, and after it lightens the background color a little bit.\n\n```scss\n$theme-orange: #FFB81A;\n\n.reveal .slides section .fragment.hl-orange {\n  opacity: unset;\n  visibility: unset;\n\n  &.visible {\n    background-color: $theme-orange;\n  }\n\n  &.current-fragment {\n    background-color: darken($theme-orange, 10%);\n  }\n}\n```\n\nThis once is nice and flexible because it is easy to extend.\n\n```scss\n$theme-orange: #FFB81A;\n$theme-yellow: #FFD571;\n$theme-brown: #E2AE86;\n$theme-pink: #FED7E1;\n\n.reveal .slides section .fragment {\n\n  &.hl-orange,\n  &.hl-yellow,\n  &.hl-pink,\n  &.hl-brown {\n    opacity: 1;\n    visibility: inherit\n  }\n\n  &.hl-brown.visible {\n    background-color: $theme-brown;\n  }\n\n  &.hl-brown.current-fragment {\n    background-color: darken($theme-brown, 10%);\n  }\n\n  &.hl-orange.visible {\n    background-color: $theme-orange;\n  }\n\n  &.hl-orange.current-fragment {\n    background-color: darken($theme-orange, 10%);\n  }\n\n  &.hl-yellow.visible {\n    background-color: $theme-yellow;\n  }\n\n  &.hl-yellow.current-fragment {\n    background-color: darken($theme-yellow, 10%);\n  }\n\n  &.hl-pink.visible {\n    background-color: $theme-pink;\n  }\n\n  &.hl-pink.current-fragment {\n    background-color: darken($theme-pink, 10%);\n  }\n}\n```\n\nAnd we are willing to tap into some scss we can condense it down quite a lot using [SCSS loops](scss.qmd#using-each-to-automatically-create-classes).\n\n```scss\n$colors: (\n  \"orange\": #FFB81A,\n  \"yellow\": #FFD571,\n  \"brown\": #E2AE86,\n  \"pink\": #FED7E1\n);\n\n@each $name, $color in $colors {\n  .reveal .slides section .fragment.hl-#{$name} {\n    opacity: unset;\n    visibility: unset;\n\n    &.visible {\n      background-color: lighten($color, 5%);\n    }\n\n    &.current-fragment {\n      background-color: $color;\n    }\n  }\n}\n```\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-highlighter.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-highlighter.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/highlighter.scss\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands sass >}}scss<a>\n\n## Example 3\n\nThe last example included a bit of flair by having the current fragment element be a slightly different color and then changing it after. We can simplify it a bit by not specifying the `.current-fragment` class.\n\n```scss\n$theme-orange: #FFB81A;\n\n.reveal .slides section .fragment.hl-orange {\n  opacity: unset;\n  visibility: unset;\n\n  &.visible {\n    background-color: $theme-orange;\n  }\n}\n```\n\nThis fragment works more or less the same way as before but doesn't change color once it is applied. It will be a more appropriate fragment many times.\n\nThis leads us to our final piece of knowledge in this blog post. We don't have to fully specify a fragment. We just have to declare how we want it to behave differently, and then the default \"stay hidden, then appear\" fragment.\n\n## Fragments 201\n\nWhen a fragment is either shown or hidden `reveal.js` (the engine that powers our slides) will dispatch an event. This event can be picked up using JavaScript.\n\nYou will need a little bit of Javascript knowledge, but I found that you don't need a lot of knowledge to produce useful things for slides. Once your slides are rendered in your browser, you can toggle the developer tools, where you can find a javascript console. This is where I do the work needed.\n\n![](media/developer-tools-fragments.png)\n\nWe can capture the event using the following snippets of code\n\n```js\nReveal.on('fragmentshown', (event) => {\n  // event.fragment = the fragment DOM element\n});\nReveal.on('fragmenthidden', (event) => {\n  // event.fragment = the fragment DOM element\n});\n```\n\n`Reveal` is the javascript object that powers the whole presentation. To have fun things happening when we use fragments, we need to write some code inside these curly brackets. The first chunk of code runs whenever a fragment appears, and the second runs whenever a fragment disappears. In in this environment, we have access to the `event` which is the DOM element of fragment div itself as created in our slides. We can take advantage of that in different ways as you will see.\n\n```js\nEvent {\n  \"isTrusted\": false,\n  \"fragment\": \"Node\",\n  \"fragments\": [\"Node\"],\n  \"type\": \"fragmentshown\",\n  \"target\": \"Node\",\n  \"currentTarget\": \"Node\",\n  \"eventPhase\": 2,\n  \"bubbles\": true,\n  \"cancelable\": true,\n  \"defaultPrevented\": false,\n  \"composed\": false,\n  \"timeStamp\": 2259.5,\n  \"srcElement\": \"Node\",\n  \"returnValue\": true,\n  \"cancelBubble\": false,\n  \"NONE\": 0,\n  \"CAPTURING_PHASE\": 1,\n  \"AT_TARGET\": 2,\n  \"BUBBLING_PHASE\": 3\n}\n```\n\nLast note, you can have multiple of these `Reveal.on()` statements, as they will trigger one after another. So depending on how you want to organize, both styles are valid.\n\n```js\n// one statement\nReveal.on('fragmentshown', (event) => {\n  fragment_style_1(event);\n  fragment_style_2(event);\n  fragment_style_3(event);\n});\n\n// multiple statements\nReveal.on('fragmentshown', (event) => {\n  fragment_style_1(event);\n});\nReveal.on('fragmentshown', (event) => {\n  fragment_style_2(event);\n});\nReveal.on('fragmentshown', (event) => {\n  fragment_style_3(event);\n});\n```\n\nLastly, the way I set up my revealjs slides to do javascript is by setting the `include-after-body` attribute in the yaml file, \n\n```yaml\nformat:\n  revealjs:\n    include-after-body: \n      - \"_color.html\"\n```\n\nand having it point to a file that looks like this:\n\n```html\n<script type=\"text/javascript\">\n\n</script>\n```\n\nthen inside we put my javascript code, which for this blog post will be some  `Reveal.on()` calls.\n\n## Color changing\n\nThis first example is going to be an illustrative example of what we can do and how to do it. And it will thus not be very useful.\n\nThe first lesson I want to show is that you are not limited to modifying the content inside the fragment. This means that we can actually have empty fragments that modify some other element. So in our document, we could have a slide that looks like this:\n\n```markdown\n## Color Changing Title Text\n\n::: {.fragment .color}\n:::\n```\n\nI want to change the color of the header when the fragment triggers. To do that we need two things.\n\n1. The color to change it into\n2. Access to the header element\n\nThe first part is easy, I found a \"random javascript\" script online. We start by assigning that to a variable.\n\n```js\nrandom_color = '#'+(Math.random()*0xFFFFFF<<0).toString(16);\n```\n\nNext, we need to find the header. Remember the `Reveal` object I mentioned earlier? It has a very handy `.getCurrentSlide()` method. When run we get the current slide we are on, which is exactly what we need.\n\n```js\nReveal.getCurrentSlide()\n<section id=​\"color-changing-title-text\" class=​\"slide level2 present\" style=​\"display:​ block;​\" data-fragment=​\"-1\">\n​  <h2>​Color Changing Title Text​</h2>\n  ​<div class=​\"fragment color\" data-fragment-index=​\"0\">​</div>\n​  <div class=​\"quarto-auto-generated-content\">​</div>​\n</section>​\n```\n\nFrom this, we can get to the title using `.querySelector()` \n\n:::: {.callout-note}\nWe don't need `.querySelectorAll()` because by definition there will only be one `h2` on a quarto slide using default options.\n:::\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"h2\")\n<h2>Color Changing Title Text</h2>\n```\n\nWe can then change the color by selecting the `style` element of the div and updating the `color` variable.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"h2\")\n  .style\n  .color = random_color;\n```\n\nAnd that is technically all we need. Put that code inside the `Reveal.on()` statements, and the color of the header will change each time the fragment is triggered.\n\nOne thing worth remembering is that this javascript code will run everything a fragment is run. So to limit it, we can make sure it only runs when we want it to. This is why I gave the fragment a `.color` class. We can use the following `if` statement to make sure our code only runs when we want it to.\n\n```js\nif (event.fragment.classList.contains(\"color\")) {\n\n}\n```\n\nWe could stop here. But I want to show a little more with this example. For right the color changes randomly, but we could allow for a little bit of information transfer. HTML has this concept called [datasets](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset). Each div can have a data set of information. We should use this to give our fragments more flexibility.\n\nLuckily it is quite effortless to specify data set values in quarto. Below is the same fragment div as before, but with a data set value named `color`.\n\n```markdown\n:::: {.fragment .color data-color=\"orange\"}\n:::\n```\n\nWe can now on the javascript side pull out this value with ease.\n\n```js\ncolor = event.fragment.dataset.color;\n```\n\n:::: {.callout-warning}\nWe are not doing any input checking, so this code will fail silently if you don't have a color specified in the div.\n:::\n\nAnd set it the same as before.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"h2\")\n  .style\n  .color = color;\n```\n\nThis will give us the final fragment code as follows\n\n```js\nReveal.on('fragmentshown', (event) => {\n  if (event.fragment.classList.contains(\"color\")) {\n random_color = '#'+(Math.random()*0xFFFFFF<<0).toString(16);\n  \n Reveal\n      .getCurrentSlide()\n      .querySelector(\"h2\")\n      .style\n      .color = random_color;\n  }\n});\n\nReveal.on('fragmenthidden', (event) => {\n  if (event.fragment.classList.contains(\"color\")) {\n color = event.fragment.dataset.color;\n\n Reveal\n      .getCurrentSlide()\n      .querySelector(\"h2\")\n      .style\n      .color = color;\n  }\n});\n```\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-color.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-color.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/color.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n\n## Scroll output\n\nSometimes you run into a situation where you want to interact with an element on a slide. This can happen when you need to scroll or toggle something. While that would be fine to do by hand, it can be hard to do casually, and impossible to do if you are using a clicker.\n\nScrolling text in a window is one thing that isn't that hard to do with JavaScript.\n\nWe will follow the same steps as before.\n\n1. Find the element we want to show\n2. Figure out how to scroll it\n\nThe element can again be found using `.getCurrentSlide()` and `querySelector()` after a little digging.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\".cell-output code\")\n```\n\nNext, we need to figure out how to scroll it. This can be done using the [.scrollTo()](https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo) method. This function should be passed on to how much we want to scroll and how. As far as I know, this can only be set using pixel values so we have to try a couple of times to get it right. `1000` appears enough for this example to get us all the way to the bottom. Setting `behavior` to smooth for a little flair.\n\n```js\n{\n  top: 1000,\n  behavior: \"smooth\",\n}\n```\n\nThis means that the fragment is finished with\n\n```js\nReveal.on('fragmentshown', (event) => {\n  if (event.fragment.classList.contains(\"scroll\")) {\n Reveal\n    .getCurrentSlide()\n    .querySelector(\".cell-output code\")\n    .scrollTo({\n top: 1000,\n behavior: \"smooth\",\n    })\n  }\n});\n```\n\nBut wait! What if you have to go back? this is where `fragmenthidden` is needed, we simply take the preview code and say we want to go back to the top by setting `top` to `0`.\n\n```js\nReveal.on('fragmenthidden', (event) => {\n  if (event.fragment.classList.contains(\"scroll\")) {\n Reveal\n    .getCurrentSlide()\n    .querySelector(\".cell-output code\")\n    .scrollTo({\n top: 0,\n behavior: \"smooth\",\n    })\n  }\n});\n```\n\n:::: {.callout-note}\nSome changes to our slides are really hard to reverse. They would thus make for bad fragments. You could implement them halfway without the `fragmenthidden` and you would just need to be really confident that you never have to go backwards in your slides.\n:::\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-scroll.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-scroll.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/scroll.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n\n:::: {.callout-tip}\nWe didn't do it here, but you could use dataset values to help determine which elements should be scrolled and how much to scroll them by instead of hardcoding it all as we do here.\n:::\n\n## Tabset advance\n\nQuarto also has [tabset](https://quarto.org/docs/presentations/revealjs/index.html#tabsets) support for slides, which is again a very nice feature. It runs into the same clicker interaction we noted earlier. It requires a mouse to correctly toggle in the middle of a presentation.\n\nWe can deal with this as well. As always we need to find the elements and how to toggle them.\n\n:::: {.callout-note}\nThe astute reader will notice that the following will only work on a tabset with 2 tabs. Making this fragment work for multiple tabs is left as an exercise for the reader.\n:::\n\nWe are again using `.getCurrentSlide()` and `querySelector()`, and with some trial and error, determine that the following two [CSS selectors](https://www.w3schools.com/cssref/css_selectors.php) captures the two tabs.\n\n- `.panel-tabset ul li:first-of-type a`\n- `.panel-tabset ul li:last-of-type a`\n\nAnd we are lucky because these elements have a working [`.click()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click) method that we can use.\n\nThis means that the full fragment looks like this:\n\n```js\nReveal.on('fragmentshown', (event) => {\n  if (event.fragment.classList.contains(\"tabswitch\")) {\n Reveal\n      .getCurrentSlide()\n      .querySelector(\".panel-tabset ul li:last-of-type a\")\n      .click()\n  }\n});\n\nReveal.on('fragmenthidden', (event) => {\n  if (event.fragment.classList.contains(\"tabswitch\")) {\n Reveal\n      .getCurrentSlide()\n      .querySelector(\".panel-tabset ul li:first-of-type a\")\n      .click()\n  }\n});\n```\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-tabset.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-tabset.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/tabset.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n\n## advance embedded slides\n\nThe last example I'll show for now is one you have seen me use already. I like to put quarto slides inside quarto slides. However, it becomes messy to advance the embedded slides, because they take focus of the mouse. I have used a fragment to advance these.\n\nWe start by embedding a set of slides in our set of slides. We do thing with `<iframe class=\"slide-deck\" src=\"fragment-scroll.html\" style=\"width:100%; height: 500px;\" ></iframe>`.\n\nThe `Reveal` object has a [fairly extensive API](https://revealjs.com/api/) you can use. So we just need to fetch the right `Reveal` object so we can use the `.left()` and `.right()` methods to advance the slides. It took me a while to find the right code, but [`.contentWindow`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/contentWindow) was the missing piece. The following returns the embedded `Reveal` object.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"iframe\")\n  .contentWindow\n  .Reveal\n```\n\nWhich then gives us the following as our fragment\n\n```js\nReveal.on('fragmentshown', event => {\n  if (event.fragment.classList.contains(\"advance-slide\")) {\n Reveal\n      .getCurrentSlide()\n       .querySelector(\"iframe\")\n      .contentWindow\n      .Reveal\n      .right()\n    }\n});\nReveal.on('fragmenthidden', event => {\n  if (event.fragment.classList.contains(\"advance-slide\")) {\n Reveal\n      .getCurrentSlide()\n      .querySelector(\"iframe\")\n      .contentWindow\n      .Reveal\n      .left()\n    }\n});\n```\n\n<iframe class=\"slide-deck\" src=\"https://emilhvitfeldt.github.io/quarto-revealjs-fragment-advance-example/\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-advance.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/advance.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n","srcMarkdownNoYaml":"\n\n## Highlight incremental slides\n\nThe use of [incremental lists](https://quarto.org/docs/presentations/revealjs/#incremental-lists) is a great way to add a little something to a set of slides. It also avoids a wall of text, allowing the presenter to show one bullet at a time. All in all, this is helpful as it can be used to focus the viewers' attention. \n\nAs a reminder, we create an incremental list using the following syntax:\n\n```markdown\n::: {.incremental}\n- thing 1\n- thing 2\n:::\n```\n\nWe can add another class to this div and use it to style it more. \n\n```markdown\n::: {.incremental .highlight-last}\n- thing 1\n- thing 2\n:::\n```\n\nthen we use this to style our list. Below `.current-fragment` refers to the last shown item in the list. Setting the `color: grey` isn't necessary, but it is a way to downplay the \"not-current\" items\n\n```scss\n.highlight-last  {\n  color: grey;\n  .current-fragment {\n    color: #5500ff;\n  }\n}\n```\n\nThese together yield these slides:\n\n<iframe class=\"slide-deck\" src=\"../examples/fragments/tip-1.html\">\n\n</iframe>\n\n<a href=\"../examples/fragments/tip-1.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"../examples/fragments/tip-1.scss\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands sass >}}scss<a>\n\n## Changing fragments with CSS\n\nAt the most fundamental level, a fragment can be split into 3 stages\n\n- before\n- current\n- after\n\ndetermining which stage is handled completely by revealjs using the `fragment-index` attribute. The way we can make things happen is to apply a different style to each of the 3 stages.\n\nthe maximal fragment signature is as follows, with `fragment-name` being the name of the fragment in question. For them to work properly you have to list them in the following order. Which corresponds to `before`, `after`, and `current`.\n\n```css\n.reveal .slides section .fragment.fragment-name {\n}\n\n.reveal .slides section .fragment.fragment-name.visible {\n}\n\n.reveal .slides section .fragment.fragment-name.current-fragment {\n}\n```\n\n:::: {.callout-important}\nThe reason why this ordering is important is because `.visible` and `.current-fragment` are triggered at the same time. And because I simplified the order a little too much. There isn't `before`, `current`, and `after`. Instead, we have `always`, `current`, and `not-before-current`. In essence, they do the same, as long as you order them in this order to make sure they cascade properly.\n:::\n\nBefore we try to implement a fragment by ourselves, we need to note one thing real quick. Each of these stages is styled a [specific way by default](https://github.com/quarto-dev/quarto-cli/blob/39dc173c4869ebaf4d6bb087a972acb87533b64e/src/resources/formats/revealjs/reveal/css/reveal.scss#L51-L65). In practice, what this means is that the `before` style has the following attributes set to make the text invisible:\n\n```css\nopacity: 0;\nvisibility: hidden;\n```\n\nIf you want the text to be visible before the fragment triggers, simply set these two attributes to `unset`.\n\nAnother note I would like to add is that while you are able to modify anything in a fragment, as it is just triggering CSS, you should be careful about position and size. While you might be able to make it work, it is likely to cause a lot of shifting and jittering as elements resize.\n\n:::: {.callout-tip}\nLooking at the [source code](https://github.com/quarto-dev/quarto-cli/blob/39dc173c4869ebaf4d6bb087a972acb87533b64e/src/resources/formats/revealjs/reveal/css/reveal.scss#L67-L207) for the default fragments gives us a good idea for how different styles of fragments work.\n:::\n\n## Example 1\n\nThis first example illustrates how the different phases work in a fragment. We have thus created an `rgb` fragment that assigns a different color to each of the 3 phases. We `unset` both `opacity` and `visibility` to have the text appear beforehand. This leaves us with the following fragment:\n\n```scss\n.reveal .slides section .fragment.rgb {\n  opacity: unset;\n  visibility: unset;\n  color: red;\n}\n\n.reveal .slides section .fragment.rgb.visible {\n  color: blue;\n}\n\n.reveal .slides section .fragment.rgb.current-fragment {\n  color: green;\n}\n```\n\nAdvancing and de-advancing(?) the slides showcase how the different classes are applied for fragments.\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-rgb.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-rgb.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/rgb.scss\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands sass >}}scss<a>\n\nWorth noting that this single fragment could be rewritten as the following using SCSS nesting.\n\n```scss\n.reveal .slides section .fragment.rgb {\n  opacity: unset;\n  visibility: unset;\n  color: red;\n\n  &.visible {\n    color: blue;\n  }\n\n  &.current-fragment {\n    color: green;\n  }\n}\n```\n\n## Example 2\n\nOne custom fragment I use from time to time is the background highlighted style. And it is very simple, instead of changing the color of the text, it changes the background color. I find that it is a much stronger indication than changing the text itself.\n\nThis fragment gives us two things. I leave the text visible beforehand. Then it turns the background orange, and after it lightens the background color a little bit.\n\n```scss\n$theme-orange: #FFB81A;\n\n.reveal .slides section .fragment.hl-orange {\n  opacity: unset;\n  visibility: unset;\n\n  &.visible {\n    background-color: $theme-orange;\n  }\n\n  &.current-fragment {\n    background-color: darken($theme-orange, 10%);\n  }\n}\n```\n\nThis once is nice and flexible because it is easy to extend.\n\n```scss\n$theme-orange: #FFB81A;\n$theme-yellow: #FFD571;\n$theme-brown: #E2AE86;\n$theme-pink: #FED7E1;\n\n.reveal .slides section .fragment {\n\n  &.hl-orange,\n  &.hl-yellow,\n  &.hl-pink,\n  &.hl-brown {\n    opacity: 1;\n    visibility: inherit\n  }\n\n  &.hl-brown.visible {\n    background-color: $theme-brown;\n  }\n\n  &.hl-brown.current-fragment {\n    background-color: darken($theme-brown, 10%);\n  }\n\n  &.hl-orange.visible {\n    background-color: $theme-orange;\n  }\n\n  &.hl-orange.current-fragment {\n    background-color: darken($theme-orange, 10%);\n  }\n\n  &.hl-yellow.visible {\n    background-color: $theme-yellow;\n  }\n\n  &.hl-yellow.current-fragment {\n    background-color: darken($theme-yellow, 10%);\n  }\n\n  &.hl-pink.visible {\n    background-color: $theme-pink;\n  }\n\n  &.hl-pink.current-fragment {\n    background-color: darken($theme-pink, 10%);\n  }\n}\n```\n\nAnd we are willing to tap into some scss we can condense it down quite a lot using [SCSS loops](scss.qmd#using-each-to-automatically-create-classes).\n\n```scss\n$colors: (\n  \"orange\": #FFB81A,\n  \"yellow\": #FFD571,\n  \"brown\": #E2AE86,\n  \"pink\": #FED7E1\n);\n\n@each $name, $color in $colors {\n  .reveal .slides section .fragment.hl-#{$name} {\n    opacity: unset;\n    visibility: unset;\n\n    &.visible {\n      background-color: lighten($color, 5%);\n    }\n\n    &.current-fragment {\n      background-color: $color;\n    }\n  }\n}\n```\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-highlighter.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-highlighter.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/highlighter.scss\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands sass >}}scss<a>\n\n## Example 3\n\nThe last example included a bit of flair by having the current fragment element be a slightly different color and then changing it after. We can simplify it a bit by not specifying the `.current-fragment` class.\n\n```scss\n$theme-orange: #FFB81A;\n\n.reveal .slides section .fragment.hl-orange {\n  opacity: unset;\n  visibility: unset;\n\n  &.visible {\n    background-color: $theme-orange;\n  }\n}\n```\n\nThis fragment works more or less the same way as before but doesn't change color once it is applied. It will be a more appropriate fragment many times.\n\nThis leads us to our final piece of knowledge in this blog post. We don't have to fully specify a fragment. We just have to declare how we want it to behave differently, and then the default \"stay hidden, then appear\" fragment.\n\n## Fragments 201\n\nWhen a fragment is either shown or hidden `reveal.js` (the engine that powers our slides) will dispatch an event. This event can be picked up using JavaScript.\n\nYou will need a little bit of Javascript knowledge, but I found that you don't need a lot of knowledge to produce useful things for slides. Once your slides are rendered in your browser, you can toggle the developer tools, where you can find a javascript console. This is where I do the work needed.\n\n![](media/developer-tools-fragments.png)\n\nWe can capture the event using the following snippets of code\n\n```js\nReveal.on('fragmentshown', (event) => {\n  // event.fragment = the fragment DOM element\n});\nReveal.on('fragmenthidden', (event) => {\n  // event.fragment = the fragment DOM element\n});\n```\n\n`Reveal` is the javascript object that powers the whole presentation. To have fun things happening when we use fragments, we need to write some code inside these curly brackets. The first chunk of code runs whenever a fragment appears, and the second runs whenever a fragment disappears. In in this environment, we have access to the `event` which is the DOM element of fragment div itself as created in our slides. We can take advantage of that in different ways as you will see.\n\n```js\nEvent {\n  \"isTrusted\": false,\n  \"fragment\": \"Node\",\n  \"fragments\": [\"Node\"],\n  \"type\": \"fragmentshown\",\n  \"target\": \"Node\",\n  \"currentTarget\": \"Node\",\n  \"eventPhase\": 2,\n  \"bubbles\": true,\n  \"cancelable\": true,\n  \"defaultPrevented\": false,\n  \"composed\": false,\n  \"timeStamp\": 2259.5,\n  \"srcElement\": \"Node\",\n  \"returnValue\": true,\n  \"cancelBubble\": false,\n  \"NONE\": 0,\n  \"CAPTURING_PHASE\": 1,\n  \"AT_TARGET\": 2,\n  \"BUBBLING_PHASE\": 3\n}\n```\n\nLast note, you can have multiple of these `Reveal.on()` statements, as they will trigger one after another. So depending on how you want to organize, both styles are valid.\n\n```js\n// one statement\nReveal.on('fragmentshown', (event) => {\n  fragment_style_1(event);\n  fragment_style_2(event);\n  fragment_style_3(event);\n});\n\n// multiple statements\nReveal.on('fragmentshown', (event) => {\n  fragment_style_1(event);\n});\nReveal.on('fragmentshown', (event) => {\n  fragment_style_2(event);\n});\nReveal.on('fragmentshown', (event) => {\n  fragment_style_3(event);\n});\n```\n\nLastly, the way I set up my revealjs slides to do javascript is by setting the `include-after-body` attribute in the yaml file, \n\n```yaml\nformat:\n  revealjs:\n    include-after-body: \n      - \"_color.html\"\n```\n\nand having it point to a file that looks like this:\n\n```html\n<script type=\"text/javascript\">\n\n</script>\n```\n\nthen inside we put my javascript code, which for this blog post will be some  `Reveal.on()` calls.\n\n## Color changing\n\nThis first example is going to be an illustrative example of what we can do and how to do it. And it will thus not be very useful.\n\nThe first lesson I want to show is that you are not limited to modifying the content inside the fragment. This means that we can actually have empty fragments that modify some other element. So in our document, we could have a slide that looks like this:\n\n```markdown\n## Color Changing Title Text\n\n::: {.fragment .color}\n:::\n```\n\nI want to change the color of the header when the fragment triggers. To do that we need two things.\n\n1. The color to change it into\n2. Access to the header element\n\nThe first part is easy, I found a \"random javascript\" script online. We start by assigning that to a variable.\n\n```js\nrandom_color = '#'+(Math.random()*0xFFFFFF<<0).toString(16);\n```\n\nNext, we need to find the header. Remember the `Reveal` object I mentioned earlier? It has a very handy `.getCurrentSlide()` method. When run we get the current slide we are on, which is exactly what we need.\n\n```js\nReveal.getCurrentSlide()\n<section id=​\"color-changing-title-text\" class=​\"slide level2 present\" style=​\"display:​ block;​\" data-fragment=​\"-1\">\n​  <h2>​Color Changing Title Text​</h2>\n  ​<div class=​\"fragment color\" data-fragment-index=​\"0\">​</div>\n​  <div class=​\"quarto-auto-generated-content\">​</div>​\n</section>​\n```\n\nFrom this, we can get to the title using `.querySelector()` \n\n:::: {.callout-note}\nWe don't need `.querySelectorAll()` because by definition there will only be one `h2` on a quarto slide using default options.\n:::\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"h2\")\n<h2>Color Changing Title Text</h2>\n```\n\nWe can then change the color by selecting the `style` element of the div and updating the `color` variable.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"h2\")\n  .style\n  .color = random_color;\n```\n\nAnd that is technically all we need. Put that code inside the `Reveal.on()` statements, and the color of the header will change each time the fragment is triggered.\n\nOne thing worth remembering is that this javascript code will run everything a fragment is run. So to limit it, we can make sure it only runs when we want it to. This is why I gave the fragment a `.color` class. We can use the following `if` statement to make sure our code only runs when we want it to.\n\n```js\nif (event.fragment.classList.contains(\"color\")) {\n\n}\n```\n\nWe could stop here. But I want to show a little more with this example. For right the color changes randomly, but we could allow for a little bit of information transfer. HTML has this concept called [datasets](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset). Each div can have a data set of information. We should use this to give our fragments more flexibility.\n\nLuckily it is quite effortless to specify data set values in quarto. Below is the same fragment div as before, but with a data set value named `color`.\n\n```markdown\n:::: {.fragment .color data-color=\"orange\"}\n:::\n```\n\nWe can now on the javascript side pull out this value with ease.\n\n```js\ncolor = event.fragment.dataset.color;\n```\n\n:::: {.callout-warning}\nWe are not doing any input checking, so this code will fail silently if you don't have a color specified in the div.\n:::\n\nAnd set it the same as before.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"h2\")\n  .style\n  .color = color;\n```\n\nThis will give us the final fragment code as follows\n\n```js\nReveal.on('fragmentshown', (event) => {\n  if (event.fragment.classList.contains(\"color\")) {\n random_color = '#'+(Math.random()*0xFFFFFF<<0).toString(16);\n  \n Reveal\n      .getCurrentSlide()\n      .querySelector(\"h2\")\n      .style\n      .color = random_color;\n  }\n});\n\nReveal.on('fragmenthidden', (event) => {\n  if (event.fragment.classList.contains(\"color\")) {\n color = event.fragment.dataset.color;\n\n Reveal\n      .getCurrentSlide()\n      .querySelector(\"h2\")\n      .style\n      .color = color;\n  }\n});\n```\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-color.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-color.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/color.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n\n## Scroll output\n\nSometimes you run into a situation where you want to interact with an element on a slide. This can happen when you need to scroll or toggle something. While that would be fine to do by hand, it can be hard to do casually, and impossible to do if you are using a clicker.\n\nScrolling text in a window is one thing that isn't that hard to do with JavaScript.\n\nWe will follow the same steps as before.\n\n1. Find the element we want to show\n2. Figure out how to scroll it\n\nThe element can again be found using `.getCurrentSlide()` and `querySelector()` after a little digging.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\".cell-output code\")\n```\n\nNext, we need to figure out how to scroll it. This can be done using the [.scrollTo()](https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo) method. This function should be passed on to how much we want to scroll and how. As far as I know, this can only be set using pixel values so we have to try a couple of times to get it right. `1000` appears enough for this example to get us all the way to the bottom. Setting `behavior` to smooth for a little flair.\n\n```js\n{\n  top: 1000,\n  behavior: \"smooth\",\n}\n```\n\nThis means that the fragment is finished with\n\n```js\nReveal.on('fragmentshown', (event) => {\n  if (event.fragment.classList.contains(\"scroll\")) {\n Reveal\n    .getCurrentSlide()\n    .querySelector(\".cell-output code\")\n    .scrollTo({\n top: 1000,\n behavior: \"smooth\",\n    })\n  }\n});\n```\n\nBut wait! What if you have to go back? this is where `fragmenthidden` is needed, we simply take the preview code and say we want to go back to the top by setting `top` to `0`.\n\n```js\nReveal.on('fragmenthidden', (event) => {\n  if (event.fragment.classList.contains(\"scroll\")) {\n Reveal\n    .getCurrentSlide()\n    .querySelector(\".cell-output code\")\n    .scrollTo({\n top: 0,\n behavior: \"smooth\",\n    })\n  }\n});\n```\n\n:::: {.callout-note}\nSome changes to our slides are really hard to reverse. They would thus make for bad fragments. You could implement them halfway without the `fragmenthidden` and you would just need to be really confident that you never have to go backwards in your slides.\n:::\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-scroll.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-scroll.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/scroll.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n\n:::: {.callout-tip}\nWe didn't do it here, but you could use dataset values to help determine which elements should be scrolled and how much to scroll them by instead of hardcoding it all as we do here.\n:::\n\n## Tabset advance\n\nQuarto also has [tabset](https://quarto.org/docs/presentations/revealjs/index.html#tabsets) support for slides, which is again a very nice feature. It runs into the same clicker interaction we noted earlier. It requires a mouse to correctly toggle in the middle of a presentation.\n\nWe can deal with this as well. As always we need to find the elements and how to toggle them.\n\n:::: {.callout-note}\nThe astute reader will notice that the following will only work on a tabset with 2 tabs. Making this fragment work for multiple tabs is left as an exercise for the reader.\n:::\n\nWe are again using `.getCurrentSlide()` and `querySelector()`, and with some trial and error, determine that the following two [CSS selectors](https://www.w3schools.com/cssref/css_selectors.php) captures the two tabs.\n\n- `.panel-tabset ul li:first-of-type a`\n- `.panel-tabset ul li:last-of-type a`\n\nAnd we are lucky because these elements have a working [`.click()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click) method that we can use.\n\nThis means that the full fragment looks like this:\n\n```js\nReveal.on('fragmentshown', (event) => {\n  if (event.fragment.classList.contains(\"tabswitch\")) {\n Reveal\n      .getCurrentSlide()\n      .querySelector(\".panel-tabset ul li:last-of-type a\")\n      .click()\n  }\n});\n\nReveal.on('fragmenthidden', (event) => {\n  if (event.fragment.classList.contains(\"tabswitch\")) {\n Reveal\n      .getCurrentSlide()\n      .querySelector(\".panel-tabset ul li:first-of-type a\")\n      .click()\n  }\n});\n```\n\n<iframe class=\"slide-deck\" src=\"examples/fragments/fragment-tabset.html\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-tabset.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/tabset.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n\n## advance embedded slides\n\nThe last example I'll show for now is one you have seen me use already. I like to put quarto slides inside quarto slides. However, it becomes messy to advance the embedded slides, because they take focus of the mouse. I have used a fragment to advance these.\n\nWe start by embedding a set of slides in our set of slides. We do thing with `<iframe class=\"slide-deck\" src=\"fragment-scroll.html\" style=\"width:100%; height: 500px;\" ></iframe>`.\n\nThe `Reveal` object has a [fairly extensive API](https://revealjs.com/api/) you can use. So we just need to fetch the right `Reveal` object so we can use the `.left()` and `.right()` methods to advance the slides. It took me a while to find the right code, but [`.contentWindow`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/contentWindow) was the missing piece. The following returns the embedded `Reveal` object.\n\n```js\nReveal\n  .getCurrentSlide()\n  .querySelector(\"iframe\")\n  .contentWindow\n  .Reveal\n```\n\nWhich then gives us the following as our fragment\n\n```js\nReveal.on('fragmentshown', event => {\n  if (event.fragment.classList.contains(\"advance-slide\")) {\n Reveal\n      .getCurrentSlide()\n       .querySelector(\"iframe\")\n      .contentWindow\n      .Reveal\n      .right()\n    }\n});\nReveal.on('fragmenthidden', event => {\n  if (event.fragment.classList.contains(\"advance-slide\")) {\n Reveal\n      .getCurrentSlide()\n      .querySelector(\"iframe\")\n      .contentWindow\n      .Reveal\n      .left()\n    }\n});\n```\n\n<iframe class=\"slide-deck\" src=\"https://emilhvitfeldt.github.io/quarto-revealjs-fragment-advance-example/\">\n</iframe>\n\n<a href=\"examples/fragments/fragment-advance.qmd\" target=\"_blank\" class=\"listing-slides btn-links\">{{< fa file >}}qmd<a>\n<a href=\"examples/fragments/advance.html\" target=\"_blank\" class=\"listing-video btn-links\">{{< fa brands js >}}js<a>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"fragments.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","bibliography":["references.bib"],"theme":["cosmo","styles.scss"],"title":"Fragments"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"fragments.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrreprt","title":"Fragments"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}